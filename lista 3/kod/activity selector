#include <iomanip>
#include <locale>
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>
#include <fstream>

using namespace std;


// liczniki krokow/porownan 
long long iter_checks = 0;      
long long rec_while_steps = 0;  
long long dp_bin_steps = 0;    

void reset_counters() {
    iter_checks = 0;
    rec_while_steps = 0;
    dp_bin_steps = 0;
}

bool ok_schedule(const vector<int>& s, const vector<int>& f, const vector<int>& pick) {
    for (int i = 1; i < (int)pick.size(); i++) {
        int prev = pick[i - 1];
        int cur = pick[i];
        if (f[prev] > s[cur]) return false;
    }
    return true;
}

// Rek
vector<int> RECURSIVE_ACTIVITY_SELECTOR(const vector<int>& s,
    const vector<int>& f,
    int k,
    int n) {
    int m = k + 1;

    while (m <= n && s[m] < f[k]) {
        rec_while_steps++; // licznik krokow w while
        m++;
    }

    if (m <= n) {
        vector<int> res;
        res.push_back(m);
        vector<int> tail = RECURSIVE_ACTIVITY_SELECTOR(s, f, m, n);
        res.insert(res.end(), tail.begin(), tail.end());
        return res;
    }
    else {
        return {};
    }
}

// iter
vector<int> ACTIVITY_SELECTOR(const vector<int>& s,
    const vector<int>& f,
    int n) {
    vector<int> A;
    if (n <= 0) return A;

    A.push_back(1);
    int k = 1;

    for (int m = 2; m <= n; m++) {
        iter_checks++;               // licznik "porownan" w if
        if (s[m] >= f[k]) {
            A.push_back(m);
            k = m;
        }
    }
    return A;
}


vector<int> DP_ACTIVITY_SELECTOR(const vector<int>& s,
    const vector<int>& f,
    int n) {
    if (n <= 0) return {};

    vector<int> p(n + 1, 0);

    for (int i = 1; i <= n; i++) {
        int lo = 0, hi = i - 1, ans = 0;
        while (lo <= hi) {
            dp_bin_steps++; // licznik krokow binary
            int mid = (lo + hi) / 2;
            if (f[mid] <= s[i]) { ans = mid; lo = mid + 1; }
            else hi = mid - 1;
        }
        p[i] = ans;
    }

    vector<int> dp(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        dp[i] = max(dp[i - 1], 1 + dp[p[i]]);
    }

    vector<int> pick;
    int i = n;
    while (i >= 1) {
        if (dp[i] == dp[i - 1]) i--;
        else { pick.push_back(i); i = p[i]; }
    }
    reverse(pick.begin(), pick.end());
    return pick;
}

// Pomiar czasu

template <typename F>
double time_ms(F fun) {
    auto t1 = chrono::high_resolution_clock::now();
    fun();
    auto t2 = chrono::high_resolution_clock::now();
    return chrono::duration<double, milli>(t2 - t1).count();
}

// Generowanie danych+ sort po f 
void generate_data(int n, mt19937& rng, vector<int>& s, vector<int>& f) {
    uniform_int_distribution<int> distS(0, 100000);
    uniform_int_distribution<int> distD(1, 1000);

    vector<pair<int, int>> acts;
    acts.reserve(n);
    for (int i = 0; i < n; i++) {
        int start = distS(rng);
        int finish = start + distD(rng);
        acts.push_back({ finish, start }); // sortujemy po finish
    }

    sort(acts.begin(), acts.end()); //rosnaco po finish

    s.assign(n + 1, 0);
    f.assign(n + 1, 0);

    // sztuczne 0 
    s[0] = 0;
    f[0] = -1000000000; // -infinity

    for (int i = 1; i <= n; i++) {
        f[i] = acts[i - 1].first;
        s[i] = acts[i - 1].second;
    }
}

// testy

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    mt19937 rng(12345);

    ofstream out("wyniki_activity_kroki.csv");
    out.imbue(std::locale::classic());      // wymusza kropke jako separator dziesietny
    out << fixed << setprecision(6);
    if (!out) {
        cout << "Blad zapisu pliku!\n";
        return 1;
    }

    out << "n,"
        "iter_avg_ms,rec_avg_ms,dp_avg_ms,"
        "iter_cnt,rec_cnt,dp_cnt,"
        "iter_checks_avg,rec_while_steps_avg,dp_bin_steps_avg\n";

    vector<int> sizes = { 100, 500, 1000, 2000, 5000, 10000 };
    int repeats = 10;

    for (int n : sizes) {
        double sumIterT = 0, sumRecT = 0, sumDpT = 0;
        long long sumIterChecks = 0, sumRecSteps = 0, sumDpSteps = 0;

        int lastIterCnt = 0, lastRecCnt = 0, lastDpCnt = 0;
        bool allIterOk = true, allRecOk = true, allDpOk = true;

        for (int r = 0; r < repeats; r++) {
            vector<int> s, f;
            generate_data(n, rng, s, f);

            vector<int> pickIter, pickRec, pickDp;

            //iter 
            reset_counters();
            double tIter = time_ms([&]() { pickIter = ACTIVITY_SELECTOR(s, f, n); });
            long long iterC = iter_checks;

            //rec
            reset_counters();
            double tRec = time_ms([&]() { pickRec = RECURSIVE_ACTIVITY_SELECTOR(s, f, 0, n); });
            long long recC = rec_while_steps;

            // dp
            reset_counters();
            double tDp = time_ms([&]() { pickDp = DP_ACTIVITY_SELECTOR(s, f, n); });
            long long dpC = dp_bin_steps;

            sumIterT += tIter; sumRecT += tRec; sumDpT += tDp;
            sumIterChecks += iterC;
            sumRecSteps += recC;
            sumDpSteps += dpC;

            bool iter_ok = ok_schedule(s, f, pickIter);
            bool rec_ok = ok_schedule(s, f, pickRec);
            bool dp_ok = ok_schedule(s, f, pickDp);

           

            lastIterCnt = (int)pickIter.size();
            lastRecCnt = (int)pickRec.size();
            lastDpCnt = (int)pickDp.size();
        }

        out << n << ";"
            << (sumIterT / repeats) << ";"
            << (sumRecT / repeats) << ";"
            << (sumDpT / repeats) << ";"
            << lastIterCnt << ";"
            << lastRecCnt << ";"
            << lastDpCnt << ";"
            << (double)sumIterChecks / repeats << ";"
            << (double)sumRecSteps / repeats << ";"
            << (double)sumDpSteps / repeats
            << "\n";

        cout << "Done n=" << n << "\n";
    }

    out.close();
    cout << "Zapisano wyniki_activity_kroki.csv\n";
    return 0;
}
